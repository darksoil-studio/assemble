import {
  require_blakejs,
  sortKeys
} from "./chunk-6MCG4PU3.js";
import {
  ActionType,
  CellType,
  Emittery,
  decodeHashFromBase64,
  encodeHashToBase64,
  flatMap_default,
  gBase64,
  isEqual_default,
  isPlainObject_default,
  uniqWith_default
} from "./chunk-BQBER75O.js";
import {
  decode,
  encode
} from "./chunk-UIQAYTRW.js";
import "./chunk-OVVSB36W.js";
import {
  __toESM
} from "./chunk-YBOLLQGG.js";

// ../node_modules/@holochain-open-dev/utils/dist/hash.js
var import_blakejs = __toESM(require_blakejs(), 1);
var HashType;
(function(HashType2) {
  HashType2[HashType2["AGENT"] = 0] = "AGENT";
  HashType2[HashType2["ENTRY"] = 1] = "ENTRY";
  HashType2[HashType2["DHTOP"] = 2] = "DHTOP";
  HashType2[HashType2["ACTION"] = 3] = "ACTION";
  HashType2[HashType2["DNA"] = 4] = "DNA";
})(HashType || (HashType = {}));
var AGENT_PREFIX = "hCAk";
var ENTRY_PREFIX = "hCEk";
var DHTOP_PREFIX = "hCQk";
var DNA_PREFIX = "hC0k";
var ACTION_PREFIX = "hCkk";
function getPrefix(type) {
  switch (type) {
    case HashType.AGENT:
      return AGENT_PREFIX;
    case HashType.ENTRY:
      return ENTRY_PREFIX;
    case HashType.DHTOP:
      return DHTOP_PREFIX;
    case HashType.ACTION:
      return ACTION_PREFIX;
    case HashType.DNA:
      return DNA_PREFIX;
    default:
      return "";
  }
}
function retype(hash2, type) {
  return new Uint8Array([
    ...gBase64.toUint8Array(getPrefix(type)),
    ...hash2.slice(3)
  ]);
}
function isHash(hash2) {
  return !![
    AGENT_PREFIX,
    ENTRY_PREFIX,
    DHTOP_PREFIX,
    DNA_PREFIX,
    ACTION_PREFIX
  ].find((prefix) => hash2.startsWith(`u${prefix}`));
}
function hash(content, type) {
  const obj = isPlainObject_default(content) ? sortKeys(content) : content;
  const bytesHash = import_blakejs.default.blake2b(encode(obj), null, 32);
  const fullhash = new Uint8Array([
    ...gBase64.toUint8Array(getPrefix(type)),
    ...bytesHash,
    ...locationBytes(bytesHash)
  ]);
  return fullhash;
}
function locationBytes(bytesHash) {
  const hash128 = import_blakejs.default.blake2b(bytesHash, null, 16);
  const out = [hash128[0], hash128[1], hash128[2], hash128[3]];
  for (let i = 4; i < 16; i += 4) {
    out[0] ^= hash128[i];
    out[1] ^= hash128[i + 1];
    out[2] ^= hash128[i + 2];
    out[3] ^= hash128[i + 3];
  }
  return new Uint8Array(out);
}
function getHashType(hash2) {
  const hashExt = encodeHashToBase64(hash2).slice(1, 5);
  if (hashExt === AGENT_PREFIX)
    return HashType.AGENT;
  if (hashExt === DNA_PREFIX)
    return HashType.DNA;
  if (hashExt === DHTOP_PREFIX)
    return HashType.DHTOP;
  if (hashExt === ACTION_PREFIX)
    return HashType.ACTION;
  if (hashExt === ENTRY_PREFIX)
    return HashType.ENTRY;
  return HashType.ENTRY;
}

// ../node_modules/@holochain-open-dev/utils/dist/fake.js
function fakeEntryHash() {
  const randomBytes = randomByteArray(36);
  return new Uint8Array([132, 33, 36, ...randomBytes]);
}
function fakeDnaHash() {
  const randomBytes = randomByteArray(36);
  return new Uint8Array([132, 45, 36, ...randomBytes]);
}
function fakeAgentPubKey() {
  const randomBytes = randomByteArray(36);
  return new Uint8Array([132, 32, 36, ...randomBytes]);
}
function fakeActionHash() {
  const randomBytes = randomByteArray(36);
  return new Uint8Array([132, 41, 36, ...randomBytes]);
}
function fakeCreateAction(entry_hash = fakeEntryHash(), author = fakeAgentPubKey()) {
  return {
    type: ActionType.Create,
    author,
    timestamp: Date.now() * 1e3,
    action_seq: 10,
    prev_action: fakeActionHash(),
    entry_type: {
      App: {
        entry_index: 0,
        visibility: { Public: null },
        zome_index: 0
      }
    },
    entry_hash
  };
}
function fakeEntry(entry = "some data") {
  return {
    entry: encode(entry),
    entry_type: "App"
  };
}
function fakeDeleteEntry(deletes_address = fakeActionHash(), deletes_entry_address = fakeEntryHash(), author = fakeAgentPubKey()) {
  return {
    type: ActionType.Delete,
    author,
    timestamp: Date.now() * 1e3,
    action_seq: 10,
    prev_action: fakeActionHash(),
    deletes_address,
    deletes_entry_address
  };
}
function fakeUpdateEntry(original_action_address = fakeActionHash(), entry = fakeEntry(), original_entry_address = fakeEntryHash(), author = fakeAgentPubKey()) {
  return {
    type: ActionType.Update,
    author,
    timestamp: Date.now() * 1e3,
    action_seq: 10,
    prev_action: fakeActionHash(),
    original_entry_address,
    original_action_address,
    entry_hash: hash(entry, HashType.ENTRY),
    entry_type: {
      App: {
        entry_index: 0,
        visibility: { Public: null },
        zome_index: 0
      }
    }
  };
}
function fakeRecord(action, entry) {
  let recordEntry = {
    NotApplicable: null
  };
  if (!entry) {
    recordEntry = {
      Present: entry
    };
  }
  return {
    entry: recordEntry,
    signed_action: {
      hashed: {
        content: action,
        hash: hash(action, HashType.ACTION)
      },
      signature: randomByteArray(256)
    }
  };
}
function randomByteArray(n) {
  const QUOTA = 65536;
  const a = new Uint8Array(n);
  for (let i = 0; i < n; i += QUOTA) {
    crypto.getRandomValues(a.subarray(i, i + Math.min(n - i, QUOTA)));
  }
  return a;
}

// ../node_modules/@holochain-open-dev/utils/dist/cell.js
function roleNameForCellId(appInfo, cellId) {
  for (const [role, cells] of Object.entries(appInfo.cell_info)) {
    for (const c of cells) {
      if (CellType.Provisioned in c) {
        if (c[CellType.Provisioned].cell_id.toString() === cellId.toString()) {
          return role;
        }
      } else if (CellType.Cloned in c) {
        return c[CellType.Cloned].clone_id ? c[CellType.Cloned].clone_id : role;
      }
    }
  }
  return void 0;
}
async function isSignalFromCellWithRole(client, roleName, signal) {
  const appInfo = await client.appInfo();
  const role = roleNameForCellId(appInfo, signal.cell_id);
  return roleName === role;
}

// ../node_modules/@holochain-open-dev/utils/dist/zome-client.js
var ZomeClient = class {
  constructor(client, roleName, zomeName) {
    this.client = client;
    this.roleName = roleName;
    this.zomeName = zomeName;
  }
  onSignal(listener) {
    return this.client.on("signal", async (signal) => {
      if (await isSignalFromCellWithRole(this.client, this.roleName, signal) && this.zomeName === signal.zome_name) {
        listener(signal.payload);
      }
    });
  }
  callZome(fn_name, payload) {
    const req = {
      role_name: this.roleName,
      zome_name: this.zomeName,
      fn_name,
      payload
    };
    return this.client.callZome(req);
  }
};

// ../node_modules/@holochain-open-dev/utils/dist/zome-mock.js
var sleep = (ms) => new Promise((r) => {
  setTimeout(() => r(null), ms);
});
var ZomeMock = class {
  constructor(roleName, zomeName, myPubKey = decodeHashFromBase64("uhCAk6oBoqygFqkDreZ0V0bH4R9cTN1OkcEG78OLxVptLWOI"), latency = 500) {
    this.roleName = roleName;
    this.zomeName = zomeName;
    this.myPubKey = myPubKey;
    this.latency = latency;
    this.emitter = new Emittery();
  }
  get cellId() {
    return [
      decodeHashFromBase64("uhCAk6oBoqygFqkDreZ0V0bH4R9cTN1OkcEG78OLxVptLWOI"),
      this.myPubKey
    ];
  }
  async appInfo() {
    return {
      agent_pub_key: this.myPubKey,
      installed_app_id: "test-app",
      status: { running: null },
      cell_info: {
        [this.roleName]: [
          {
            provisioned: {
              cell_id: this.cellId,
              name: this.roleName,
              dna_modifiers: {
                network_seed: "",
                origin_time: Date.now(),
                properties: void 0,
                quantum_time: {
                  secs: Date.now() / 1e3,
                  nanos: 0
                }
              }
            }
          }
        ]
      }
    };
  }
  createCloneCell(_args) {
    throw new Error("Method not implemented.");
  }
  enableCloneCell(_args) {
    throw new Error("Method not implemented");
  }
  disableCloneCell(_args) {
    throw new Error("Method not implemented");
  }
  async callZome(req) {
    await sleep(this.latency);
    return this[req.fn_name](req.payload);
  }
  on(eventName, listener) {
    return this.emitter.on(eventName, listener);
  }
  emitSignal(payload) {
    this.emitter.emit("signal", {
      cell_id: this.cellId,
      zome_name: this.zomeName,
      payload
    });
  }
};

// ../node_modules/@holochain-open-dev/utils/dist/holo-hash-map.js
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CellMap_cellMap;
var HoloHashMap = class {
  constructor(initialEntries) {
    this._map = /* @__PURE__ */ new Map();
    if (initialEntries) {
      for (const [key, value] of initialEntries) {
        this.set(key, value);
      }
    }
  }
  has(key) {
    return this._map.has(encodeHashToBase64(key));
  }
  get(key) {
    return this._map.get(encodeHashToBase64(key));
  }
  set(key, value) {
    this._map.set(encodeHashToBase64(key), value);
    return this;
  }
  delete(key) {
    return this._map.delete(encodeHashToBase64(key));
  }
  keys() {
    return Array.from(this._map.keys()).map((h) => decodeHashFromBase64(h))[Symbol.iterator]();
  }
  values() {
    return this._map.values();
  }
  entries() {
    return Array.from(this._map.entries()).map(([h, v]) => [decodeHashFromBase64(h), v])[Symbol.iterator]();
  }
  clear() {
    return this._map.clear();
  }
  forEach(callbackfn, thisArg) {
    return this._map.forEach((value, key) => {
      callbackfn(value, decodeHashFromBase64(key), this);
    }, thisArg);
  }
  get size() {
    return this._map.size;
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get [Symbol.toStringTag]() {
    return this._map[Symbol.toStringTag];
  }
};
var EntryHashMap = class extends HoloHashMap {
};
var ActionHashMap = class extends HoloHashMap {
};
var AgentPubKeyMap = class extends HoloHashMap {
};
var DnaHashMap = class extends HoloHashMap {
};
var CellMap = class {
  constructor(initialEntries) {
    _CellMap_cellMap.set(this, new HoloHashMap());
    if (initialEntries) {
      for (const [cellId, value] of initialEntries) {
        this.set(cellId, value);
      }
    }
  }
  get([dnaHash, agentPubKey]) {
    return __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash) ? __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash).get(agentPubKey) : void 0;
  }
  has(cellId) {
    return !!this.get(cellId);
  }
  valuesForDna(dnaHash) {
    const dnaMap = __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash);
    return dnaMap ? Array.from(dnaMap.values()) : [];
  }
  agentsForDna(dnaHash) {
    const dnaMap = __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash);
    return dnaMap ? Array.from(dnaMap.keys()) : [];
  }
  set([dnaHash, agentPubKey], value) {
    if (!__classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash))
      __classPrivateFieldGet(this, _CellMap_cellMap, "f").set(dnaHash, new HoloHashMap());
    __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash).set(agentPubKey, value);
  }
  delete([dnaHash, agentPubKey]) {
    if (__classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash)) {
      __classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash).delete(agentPubKey);
      if (Array.from(__classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash).keys()).length === 0) {
        __classPrivateFieldGet(this, _CellMap_cellMap, "f").delete(dnaHash);
      }
    }
  }
  entries() {
    return this.cellIds().map((cellId) => [cellId, this.get(cellId)]);
  }
  filter(fn) {
    const entries = this.entries();
    const mappedValues = entries.filter(([id, v]) => fn(v));
    return new CellMap(mappedValues);
  }
  map(fn) {
    const entries = this.entries();
    const mappedValues = entries.map(([id, v]) => [id, fn(v)]);
    return new CellMap(mappedValues);
  }
  values() {
    return this.cellIds().map((cellId) => this.get(cellId));
  }
  cellIds() {
    const dnaHashes = Array.from(__classPrivateFieldGet(this, _CellMap_cellMap, "f").keys());
    return flatMap_default(dnaHashes, (dnaHash) => Array.from(__classPrivateFieldGet(this, _CellMap_cellMap, "f").get(dnaHash).keys()).map((agentPubKey) => [dnaHash, agentPubKey]));
  }
};
_CellMap_cellMap = /* @__PURE__ */ new WeakMap();
var LazyMap = class {
  constructor(newValue) {
    this.newValue = newValue;
    this.map = /* @__PURE__ */ new Map();
  }
  get(hash2) {
    if (!this.map.has(hash2)) {
      this.map.set(hash2, this.newValue(hash2));
    }
    return this.map.get(hash2);
  }
};
var LazyHoloHashMap = class {
  constructor(newValue) {
    this.newValue = newValue;
    this.map = new HoloHashMap();
  }
  get(hash2) {
    if (!this.map.has(hash2)) {
      this.map.set(hash2, this.newValue(hash2));
    }
    return this.map.get(hash2);
  }
};

// ../node_modules/@holochain-open-dev/utils/dist/map-utils.js
function slice(map, keys) {
  const newMap = new HoloHashMap();
  for (const key of keys) {
    newMap.set(key, map.get(key));
  }
  return newMap;
}
function pick(map, filter) {
  const values = pickBy(map, (_v, k) => filter(k));
  return new HoloHashMap(Object.values(values).map(({ hash: hash2, value }) => [hash2, value]));
}
function pickBy(map, filter) {
  const entries = Array.from(map.entries()).filter(([key, value]) => filter(value, key));
  return new HoloHashMap(entries);
}
function mapValues(map, mappingFn) {
  const mappedMap = new HoloHashMap();
  for (const [key, value] of map.entries()) {
    mappedMap.set(key, mappingFn(value, key));
  }
  return mappedMap;
}
function mapLazyValues(map, mappingFn) {
  return new LazyHoloHashMap((key) => {
    const value = map.get(key);
    return mappingFn(value, key);
  });
}

// ../node_modules/@holochain-open-dev/utils/dist/timestamp.js
function millisToTimestamp(millis) {
  return millis * 1e3;
}
function timestampToMillis(timestamp) {
  return Math.floor(timestamp / 1e3);
}

// ../node_modules/@holochain-open-dev/utils/dist/entry-record.js
function decodeEntry(record) {
  var _a, _b;
  const entry = (_b = (_a = record.entry) == null ? void 0 : _a.Present) == null ? void 0 : _b.entry;
  return decode(entry);
}
var EntryRecord = class {
  constructor(record) {
    this.record = record;
  }
  get actionHash() {
    return this.record.signed_action.hashed.hash;
  }
  get action() {
    const action = this.record.signed_action.hashed.content;
    return {
      ...action,
      timestamp: timestampToMillis(action.timestamp)
    };
  }
  get entry() {
    return decodeEntry(this.record);
  }
  get entryHash() {
    return this.record.signed_action.hashed.content.entry_hash;
  }
};

// ../node_modules/@holochain-open-dev/utils/dist/record-bag.js
var RecordBag = class {
  get entriesByAuthor() {
    const temp = mapValues(this.authorMap, (actionHashes) => actionHashes.map((hash2) => this.actionMap.get(hash2)));
    return mapValues(temp, (actions) => actions.map((action) => this.entryMap.get(action.entry_hash)).filter((entry) => entry !== void 0));
  }
  get entryRecords() {
    return this.records.map((r) => new EntryRecord(r));
  }
  entryRecord(actionHash) {
    const record = this.records.find((r) => isEqual_default(r.signed_action.hashed.hash, actionHash));
    return record ? new EntryRecord(record) : void 0;
  }
  constructor(records = []) {
    this.records = records;
    this.entryMap = new EntryHashMap();
    this.actionMap = new ActionHashMap();
    this.entryActions = new EntryHashMap();
    this.authorMap = new AgentPubKeyMap();
    this.updates = new ActionHashMap();
    this.deletes = new ActionHashMap();
    this.add(records);
  }
  add(records) {
    this.records = this.records.concat(records);
    for (const record of records) {
      const entryRecord = new EntryRecord(record);
      if (entryRecord.entryHash) {
        this.entryMap.set(entryRecord.entryHash, entryRecord.entry);
        if (!this.entryActions.has(entryRecord.entryHash)) {
          this.entryActions.set(entryRecord.entryHash, []);
        }
        this.entryActions.set(entryRecord.entryHash, uniqWith_default([
          ...this.entryActions.get(entryRecord.entryHash),
          entryRecord.actionHash
        ], isEqual_default));
      }
      this.actionMap.set(entryRecord.actionHash, entryRecord.action);
      if (!this.authorMap.has(entryRecord.action.author)) {
        this.authorMap.set(entryRecord.action.author, []);
      }
      this.authorMap.set(entryRecord.action.author, uniqWith_default([
        ...this.authorMap.get(entryRecord.action.author),
        entryRecord.actionHash
      ], isEqual_default));
      if (entryRecord.action.original_action_address) {
        const originalActionAddress = entryRecord.action.original_action_address;
        const currentUpdates = this.updates.get(originalActionAddress);
        this.updates.set(originalActionAddress, uniqWith_default([...currentUpdates, entryRecord.actionHash], isEqual_default));
      }
      if (entryRecord.action.deletes_address) {
        const originalActionAddress = entryRecord.action.deletes_address;
        const currentDeletes = this.deletes.get(originalActionAddress);
        this.deletes.set(originalActionAddress, uniqWith_default([...currentDeletes, entryRecord.actionHash], isEqual_default));
      }
    }
  }
  addBag(recordBag) {
    this.add(recordBag.records);
  }
};

// ../node_modules/@holochain-open-dev/utils/dist/entry-state.js
function entryState(bag, originalActionHash) {
  var _a;
  const original = bag.entryRecord(originalActionHash);
  const deleted = ((_a = bag.deletes.get(originalActionHash)) == null ? void 0 : _a.length) > 0;
  const updatesActionsHashes = bag.updates.get(originalActionHash) || [];
  const updatesActions = updatesActionsHashes.map((h) => [h, bag.actionMap.get(h)]).filter((a) => a[1] !== void 0);
  const orderedActions = updatesActions.sort((a, b) => b[1].timestamp - a[1].timestamp);
  const lastActionHash = orderedActions.length === 0 ? original == null ? void 0 : original.actionHash : orderedActions[0][0];
  if (!lastActionHash)
    return void 0;
  const lastUpdate = bag.entryRecord(lastActionHash);
  return {
    deleted,
    lastUpdate
  };
}
export {
  ACTION_PREFIX,
  AGENT_PREFIX,
  ActionHashMap,
  AgentPubKeyMap,
  CellMap,
  DHTOP_PREFIX,
  DNA_PREFIX,
  DnaHashMap,
  ENTRY_PREFIX,
  EntryHashMap,
  EntryRecord,
  HashType,
  HoloHashMap,
  LazyHoloHashMap,
  LazyMap,
  RecordBag,
  ZomeClient,
  ZomeMock,
  decodeEntry,
  entryState,
  fakeActionHash,
  fakeAgentPubKey,
  fakeCreateAction,
  fakeDeleteEntry,
  fakeDnaHash,
  fakeEntry,
  fakeEntryHash,
  fakeRecord,
  fakeUpdateEntry,
  getHashType,
  hash,
  isHash,
  isSignalFromCellWithRole,
  locationBytes,
  mapLazyValues,
  mapValues,
  millisToTimestamp,
  pick,
  pickBy,
  retype,
  roleNameForCellId,
  slice,
  timestampToMillis
};
//# sourceMappingURL=@holochain-open-dev_utils.js.map
