import {
  profilesStoreContext
} from "./chunk-23FC4LHD.js";
import {
  asyncDeriveStore,
  asyncReadable,
  joinAsyncMap,
  lazyLoad,
  lazyLoadAndPoll
} from "./chunk-7ZTK7722.js";
import "./chunk-Y22KWEZP.js";
import {
  require_blakejs
} from "./chunk-6MCG4PU3.js";
import {
  CellType,
  decodeHashFromBase64,
  encodeHashToBase64
} from "./chunk-BQBER75O.js";
import {
  decode
} from "./chunk-UIQAYTRW.js";
import "./chunk-OVVSB36W.js";
import "./chunk-3YCQAOGZ.js";
import "./chunk-HKTNVJXR.js";
import {
  __toESM
} from "./chunk-YBOLLQGG.js";

// ../node_modules/@holochain-open-dev/profiles/node_modules/@holochain-open-dev/utils/dist/hash.js
var import_blakejs = __toESM(require_blakejs(), 1);
var HashType;
(function(HashType2) {
  HashType2[HashType2["AGENT"] = 0] = "AGENT";
  HashType2[HashType2["ENTRY"] = 1] = "ENTRY";
  HashType2[HashType2["DHTOP"] = 2] = "DHTOP";
  HashType2[HashType2["ACTION"] = 3] = "ACTION";
  HashType2[HashType2["DNA"] = 4] = "DNA";
})(HashType || (HashType = {}));

// ../node_modules/@holochain-open-dev/profiles/node_modules/@holochain-open-dev/utils/dist/cell.js
function roleNameForCellId(appInfo, cellId) {
  for (const [role, cells] of Object.entries(appInfo.cell_info)) {
    for (const c of cells) {
      if (CellType.Provisioned in c) {
        if (c[CellType.Provisioned].cell_id.toString() === cellId.toString()) {
          return role;
        }
      } else if (CellType.Cloned in c) {
        return c[CellType.Cloned].clone_id ? c[CellType.Cloned].clone_id : role;
      }
    }
  }
  return void 0;
}
async function isSignalFromCellWithRole(client, roleName, signal) {
  const appInfo = await client.appInfo();
  const role = roleNameForCellId(appInfo, signal.cell_id);
  return roleName === role;
}

// ../node_modules/@holochain-open-dev/profiles/node_modules/@holochain-open-dev/utils/dist/zome-client.js
var ZomeClient = class {
  constructor(client, roleName, zomeName) {
    this.client = client;
    this.roleName = roleName;
    this.zomeName = zomeName;
  }
  onSignal(listener) {
    return this.client.on("signal", async (signal) => {
      if (await isSignalFromCellWithRole(this.client, this.roleName, signal) && this.zomeName === signal.zome_name) {
        listener(signal.payload);
      }
    });
  }
  callZome(fn_name, payload) {
    const req = {
      role_name: this.roleName,
      zome_name: this.zomeName,
      fn_name,
      payload
    };
    return this.client.callZome(req);
  }
};

// ../node_modules/@holochain-open-dev/profiles/node_modules/@holochain-open-dev/utils/dist/holo-hash-map.js
var _CellMap_cellMap;
var HoloHashMap = class {
  constructor(initialEntries) {
    this._map = /* @__PURE__ */ new Map();
    if (initialEntries) {
      for (const [key, value] of initialEntries) {
        this.set(key, value);
      }
    }
  }
  has(key) {
    return this._map.has(encodeHashToBase64(key));
  }
  get(key) {
    return this._map.get(encodeHashToBase64(key));
  }
  set(key, value) {
    this._map.set(encodeHashToBase64(key), value);
    return this;
  }
  delete(key) {
    return this._map.delete(encodeHashToBase64(key));
  }
  keys() {
    return Array.from(this._map.keys()).map((h) => decodeHashFromBase64(h))[Symbol.iterator]();
  }
  values() {
    return this._map.values();
  }
  entries() {
    return Array.from(this._map.entries()).map(([h, v]) => [decodeHashFromBase64(h), v])[Symbol.iterator]();
  }
  clear() {
    return this._map.clear();
  }
  forEach(callbackfn, thisArg) {
    return this._map.forEach((value, key) => {
      callbackfn(value, decodeHashFromBase64(key), this);
    }, thisArg);
  }
  get size() {
    return this._map.size;
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get [Symbol.toStringTag]() {
    return this._map[Symbol.toStringTag];
  }
};
_CellMap_cellMap = /* @__PURE__ */ new WeakMap();
var LazyHoloHashMap = class {
  constructor(newValue) {
    this.newValue = newValue;
    this.map = new HoloHashMap();
  }
  get(hash) {
    if (!this.map.has(hash)) {
      this.map.set(hash, this.newValue(hash));
    }
    return this.map.get(hash);
  }
};

// ../node_modules/@holochain-open-dev/profiles/node_modules/@holochain-open-dev/utils/dist/map-utils.js
function slice(map, keys) {
  const newMap = new HoloHashMap();
  for (const key of keys) {
    newMap.set(key, map.get(key));
  }
  return newMap;
}

// ../node_modules/@holochain-open-dev/profiles/node_modules/@holochain-open-dev/utils/dist/entry-record.js
function decodeEntry(record) {
  var _a, _b;
  const entry = (_b = (_a = record.entry) == null ? void 0 : _a.Present) == null ? void 0 : _b.entry;
  return decode(entry);
}

// ../node_modules/@holochain-open-dev/profiles/dist/profiles-client.js
var ProfilesClient = class extends ZomeClient {
  constructor(client, roleName, zomeName = "profiles") {
    super(client, roleName, zomeName);
    this.client = client;
    this.roleName = roleName;
    this.zomeName = zomeName;
  }
  /**
   * Get the profile for the given agent, if they have created it
   *
   * @param agentPubKey the agent to get the profile for
   * @returns the profile of the agent, if they have created one
   */
  async getAgentProfile(agentPubKey) {
    const record = await this.callZome("get_agent_profile", agentPubKey);
    return record ? decodeEntry(record) : void 0;
  }
  /**
   * Search profiles that start with nicknameFilter
   *
   * @param nicknameFilter must be of at least 3 characters
   * @returns the agents with the nickname starting with nicknameFilter
   */
  async searchAgents(nicknameFilter) {
    return this.callZome("search_agents", nicknameFilter);
  }
  /**
   * Get all the agents in the DHT that have created a profile
   *
   * @returns the agent public keys of all agents that have created a profile
   */
  async getAgentsWithProfile() {
    return this.callZome("get_agents_with_profile", null);
  }
  /**
   * Create my profile
   *
   * @param profile the profile to create
   */
  async createProfile(profile) {
    return this.callZome("create_profile", profile);
  }
  /**
   * Update my profile
   *
   * @param profile the profile to create
   */
  async updateProfile(profile) {
    return this.callZome("update_profile", profile);
  }
};

// ../node_modules/@holochain-open-dev/profiles/dist/config.js
var defaultConfig = {
  avatarMode: "avatar-optional",
  additionalFields: [],
  minNicknameLength: 3
};

// ../node_modules/@holochain-open-dev/profiles/dist/profiles-store.js
var ProfilesStore = class {
  constructor(client, config = {}) {
    this.client = client;
    this.agentsWithProfile = lazyLoadAndPoll(() => this.client.getAgentsWithProfile(), 1e3);
    this.allProfiles = asyncDeriveStore(this.agentsWithProfile, (agents) => this.agentsProfiles(agents));
    this.profiles = new LazyHoloHashMap((agent) => asyncReadable(async (set) => {
      const profile = await this.client.getAgentProfile(agent);
      set(profile);
      return this.client.onSignal((signal) => {
        if (this.client.client.myPubKey.toString() !== agent.toString())
          return;
        if (!(signal.type === "EntryCreated" || signal.type === "EntryUpdated"))
          return;
        set(signal.app_entry);
      });
    }));
    this.myProfile = this.profiles.get(this.client.client.myPubKey);
    this.config = { ...defaultConfig, ...config };
  }
  // Fetches the profiles for the given agents
  agentsProfiles(agents) {
    return joinAsyncMap(slice(this.profiles, agents));
  }
  searchProfiles(searchFilter) {
    return asyncDeriveStore(lazyLoad(async () => this.client.searchAgents(searchFilter)), (agents) => this.agentsProfiles(agents));
  }
};
export {
  ProfilesClient,
  ProfilesStore,
  defaultConfig,
  profilesStoreContext
};
//# sourceMappingURL=@holochain-open-dev_profiles.js.map
