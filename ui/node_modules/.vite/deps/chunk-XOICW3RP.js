import {
  notEqual
} from "./chunk-Y22KWEZP.js";
import {
  require_blakejs
} from "./chunk-6MCG4PU3.js";
import {
  decodeHashFromBase64,
  encodeHashToBase64,
  isEqual_default
} from "./chunk-ODJ5DLEM.js";
import {
  __toESM
} from "./chunk-YBOLLQGG.js";

// ../node_modules/svelte/internal/index.mjs
function noop() {
}
function run(fn) {
  return fn();
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
var render_callbacks = [];
var resolved_promise = Promise.resolve();
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr, _oldValue, newValue) {
      this[attr] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}

// ../node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (started) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
function readonly(store) {
  return {
    subscribe: store.subscribe.bind(store)
  };
}

// ../node_modules/lit-svelte-stores/dist/store-subscriber.js
var StoreSubscriber = class {
  constructor(host, getStore, resubscribeIfChanged) {
    this.host = host;
    this.getStore = getStore;
    this.resubscribeIfChanged = resubscribeIfChanged;
    host.addController(this);
  }
  hostUpdate() {
    const store = this.store();
    if (this.shouldResubscribe(store)) {
      this.unsubscribe();
      if (store) {
        this._unsubscribe = store.subscribe((value) => {
          this.value = value;
          this.host.requestUpdate();
        });
      }
      this._previousStore = store;
    }
  }
  hostDisconnected() {
    this.unsubscribe();
  }
  unsubscribe() {
    if (this._unsubscribe) {
      this._unsubscribe();
      this._unsubscribe = void 0;
    }
  }
  shouldResubscribe(store) {
    if (this.resubscribeIfChanged) {
      const args = this.resubscribeIfChanged();
      const prev = this._previousArgs;
      this._previousArgs = args;
      return !isEqual_default(args, prev);
    } else {
      if (store === this._previousStore)
        return false;
      if (store && this._previousStore && get_store_value(store) === this.value)
        return false;
      return true;
    }
  }
  store() {
    return this.getStore();
  }
};

// ../node_modules/@lit-labs/task/development/task.js
var TaskStatus = {
  INITIAL: 0,
  PENDING: 1,
  COMPLETE: 2,
  ERROR: 3
};
var initialState = Symbol();
var Task = class {
  constructor(host, task, args) {
    this._callId = 0;
    this.status = TaskStatus.INITIAL;
    this.autoRun = true;
    this._host = host;
    this._host.addController(this);
    const taskConfig = typeof task === "object" ? task : { task, args };
    this._task = taskConfig.task;
    this._getArgs = taskConfig.args;
    if (taskConfig.autoRun !== void 0) {
      this.autoRun = taskConfig.autoRun;
    }
    this.taskComplete = new Promise((res, rej) => {
      this._resolveTaskComplete = res;
      this._rejectTaskComplete = rej;
    });
  }
  hostUpdated() {
    this.performTask();
  }
  async performTask() {
    var _a;
    const args = (_a = this._getArgs) === null || _a === void 0 ? void 0 : _a.call(this);
    if (this.shouldRun(args)) {
      this.run(args);
    }
  }
  /**
   * Determines if the task should run when it's triggered as part of the
   * host's reactive lifecycle. Note, this is not checked when `run` is
   * explicitly called. A task runs automatically when `autoRun` is `true` and
   * either its arguments change.
   * @param args The task's arguments
   * @returns
   */
  shouldRun(args) {
    return this.autoRun && this._argsDirty(args);
  }
  /**
   * A task runs when its arguments change, as long as the `autoRun` option
   * has not been set to false. To explicitly run a task outside of these
   * conditions, call `run`. A custom set of arguments can optionally be passed
   * and if not given, the configured arguments are used.
   * @param args optional set of arguments to use for this task run
   */
  async run(args) {
    var _a;
    args !== null && args !== void 0 ? args : args = (_a = this._getArgs) === null || _a === void 0 ? void 0 : _a.call(this);
    if (this.status === TaskStatus.COMPLETE || this.status === TaskStatus.ERROR) {
      this.taskComplete = new Promise((res, rej) => {
        this._resolveTaskComplete = res;
        this._rejectTaskComplete = rej;
      });
    }
    this.status = TaskStatus.PENDING;
    this._error = void 0;
    this._value = void 0;
    let result;
    let error;
    this._host.requestUpdate();
    const key = ++this._callId;
    try {
      result = await this._task(args);
    } catch (e) {
      error = e;
    }
    if (this._callId === key) {
      if (result === initialState) {
        this.status = TaskStatus.INITIAL;
      } else {
        if (error === void 0) {
          this.status = TaskStatus.COMPLETE;
          this._resolveTaskComplete(result);
        } else {
          this.status = TaskStatus.ERROR;
          this._rejectTaskComplete(error);
        }
        this._value = result;
        this._error = error;
      }
      this._host.requestUpdate();
    }
  }
  get value() {
    return this._value;
  }
  get error() {
    return this._error;
  }
  render(renderer) {
    var _a, _b, _c, _d;
    switch (this.status) {
      case TaskStatus.INITIAL:
        return (_a = renderer.initial) === null || _a === void 0 ? void 0 : _a.call(renderer);
      case TaskStatus.PENDING:
        return (_b = renderer.pending) === null || _b === void 0 ? void 0 : _b.call(renderer);
      case TaskStatus.COMPLETE:
        return (_c = renderer.complete) === null || _c === void 0 ? void 0 : _c.call(renderer, this.value);
      case TaskStatus.ERROR:
        return (_d = renderer.error) === null || _d === void 0 ? void 0 : _d.call(renderer, this.error);
      default:
        this.status;
    }
  }
  _argsDirty(args) {
    const prev = this._previousArgs;
    this._previousArgs = args;
    return Array.isArray(args) && Array.isArray(prev) ? args.length === prev.length && args.some((v, i) => notEqual(v, prev[i])) : args !== prev;
  }
};

// ../node_modules/lit-svelte-stores/dist/task-subscriber.js
var TaskSubscriber = class extends Task {
  constructor(host, task, args) {
    super(host, (a) => this.runAndSubscribe(a), args);
    this.host = host;
    this.task = task;
    this.args = args;
    this._init = false;
  }
  async hostUpdated() {
    var _a;
    super.hostUpdated();
    if (!this._init) {
      this._init = true;
      const args = (_a = this.args) === null || _a === void 0 ? void 0 : _a.call(this);
      await this.run(args);
    }
  }
  async runAndSubscribe(args) {
    if (this._storeSubscriber) {
      this._storeSubscriber.unsubscribe();
    }
    const store = await this.task(args);
    this._storeSubscriber = new StoreSubscriber(this.host, () => store);
    return store;
  }
  get value() {
    var _a;
    return (_a = this._storeSubscriber) === null || _a === void 0 ? void 0 : _a.value;
  }
  render(renderer) {
    var _a;
    if (this.status === TaskStatus.COMPLETE)
      return (_a = renderer.complete) === null || _a === void 0 ? void 0 : _a.call(renderer, this._storeSubscriber.value);
    else
      super.render(renderer);
  }
};

// ../node_modules/@holochain-open-dev/stores/dist/async-derived.js
var isPromise = (v) => typeof v === "object" && typeof v.then === "function";
function asyncDerived(store, derive) {
  return derived(store, (value, set) => {
    if (value.status === "error")
      set(value);
    else if (value.status === "pending")
      set(value);
    else {
      const v = derive(value.value);
      if (isPromise(v)) {
        set({ status: "pending" });
        Promise.resolve(v).then((v2) => {
          set({
            status: "complete",
            value: v2
          });
        }).catch((error) => {
          set({
            status: "error",
            error
          });
        });
      } else {
        set({
          status: "complete",
          value: v
        });
      }
    }
  });
}
function join(stores) {
  return derived(stores, (values) => {
    const firstError = values.find((v2) => v2 && v2.status === "error");
    if (firstError) {
      return firstError;
    }
    const firstLoading = values.find((v2) => v2 && v2.status === "pending");
    if (firstLoading) {
      return firstLoading;
    }
    const v = values.map((v2) => {
      if (v2 && v2.status === "complete")
        return v2.value;
      return v2;
    });
    return {
      status: "complete",
      value: v
    };
  });
}
function deriveStore(store, deriveStoreFn) {
  return derived(store, (value, set) => deriveStoreFn(value).subscribe(set));
}
function asyncDeriveStore(store, deriveStoreFn) {
  return derived(store, (value, set) => {
    if (value.status === "error")
      set(value);
    else if (value.status === "pending")
      set(value);
    else {
      const v = deriveStoreFn(value.value);
      if (isPromise(v)) {
        let unsubscribe;
        set({ status: "pending" });
        Promise.resolve(v).then((v2) => {
          unsubscribe = v2.subscribe(set);
        }).catch((error) => {
          set({
            status: "error",
            error
          });
        });
        return () => {
          if (unsubscribe)
            unsubscribe();
        };
      } else {
        return v.subscribe(set);
      }
    }
    return void 0;
  });
}

// ../node_modules/@holochain-open-dev/stores/node_modules/@holochain-open-dev/utils/dist/hash.js
var import_blakejs = __toESM(require_blakejs(), 1);
var HashType;
(function(HashType2) {
  HashType2[HashType2["AGENT"] = 0] = "AGENT";
  HashType2[HashType2["ENTRY"] = 1] = "ENTRY";
  HashType2[HashType2["DHTOP"] = 2] = "DHTOP";
  HashType2[HashType2["ACTION"] = 3] = "ACTION";
  HashType2[HashType2["DNA"] = 4] = "DNA";
})(HashType || (HashType = {}));

// ../node_modules/@holochain-open-dev/stores/node_modules/@holochain-open-dev/utils/dist/holo-hash-map.js
var _CellMap_cellMap;
var HoloHashMap = class {
  constructor(initialEntries) {
    this._map = /* @__PURE__ */ new Map();
    if (initialEntries) {
      for (const [key, value] of initialEntries) {
        this.set(key, value);
      }
    }
  }
  has(key) {
    return this._map.has(encodeHashToBase64(key));
  }
  get(key) {
    return this._map.get(encodeHashToBase64(key));
  }
  set(key, value) {
    this._map.set(encodeHashToBase64(key), value);
    return this;
  }
  delete(key) {
    return this._map.delete(encodeHashToBase64(key));
  }
  keys() {
    return Array.from(this._map.keys()).map((h) => decodeHashFromBase64(h))[Symbol.iterator]();
  }
  values() {
    return this._map.values();
  }
  entries() {
    return Array.from(this._map.entries()).map(([h, v]) => [decodeHashFromBase64(h), v])[Symbol.iterator]();
  }
  clear() {
    return this._map.clear();
  }
  forEach(callbackfn, thisArg) {
    return this._map.forEach((value, key) => {
      callbackfn(value, decodeHashFromBase64(key), this);
    }, thisArg);
  }
  get size() {
    return this._map.size;
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get [Symbol.toStringTag]() {
    return this._map[Symbol.toStringTag];
  }
};
_CellMap_cellMap = /* @__PURE__ */ new WeakMap();

// ../node_modules/@holochain-open-dev/stores/dist/join-map.js
function joinMap(holoHashMap) {
  const storeArray = Array.from(holoHashMap.entries()).map(([key, store]) => derived([store], ([v]) => [key, v]));
  const arrayStore = derived(storeArray, (i) => i);
  return derived([arrayStore], ([entries]) => new HoloHashMap(entries));
}
function joinAsyncMap(holoHashMap) {
  const storeArray = Array.from(holoHashMap.entries()).map(([key, store]) => asyncDerived(store, (v) => [key, v]));
  const arrayStore = join(storeArray);
  return asyncDerived(arrayStore, (entries) => new HoloHashMap(entries));
}

// ../node_modules/@holochain-open-dev/stores/dist/async-readable.js
function asyncReadable(load) {
  return readable({ status: "pending" }, (set) => {
    const asyncSet = (v) => set({ status: "complete", value: v });
    let unsubscribe;
    load(asyncSet).then((u) => {
      unsubscribe = u;
    }).catch((e) => set({ status: "error", error: e }));
    return () => unsubscribe && unsubscribe();
  });
}
function lazyLoad(load) {
  return readable({ status: "pending" }, (set) => {
    load().then((v) => {
      set({ status: "complete", value: v });
    }).catch((e) => set({ status: "error", error: e }));
    return () => {
    };
  });
}
function lazyLoadAndPoll(load, pollIntervalMs) {
  return readable({ status: "pending" }, (set) => {
    let interval;
    let currentValue;
    async function l() {
      const v = await load();
      if (!isEqual_default(v, currentValue)) {
        currentValue = v;
        set({ status: "complete", value: v });
      }
    }
    l().then(() => {
      interval = setInterval(() => l().catch(() => {
      }), pollIntervalMs);
    }).catch((e) => {
      set({ status: "error", error: e });
    });
    return () => {
      if (interval)
        clearInterval(interval);
    };
  });
}

export {
  get_store_value,
  readable,
  writable,
  derived,
  readonly,
  StoreSubscriber,
  TaskSubscriber,
  asyncDerived,
  join,
  deriveStore,
  asyncDeriveStore,
  joinMap,
  joinAsyncMap,
  asyncReadable,
  lazyLoad,
  lazyLoadAndPoll
};
/*! Bundled license information:

@lit-labs/task/development/task.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/task/development/index.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-XOICW3RP.js.map
